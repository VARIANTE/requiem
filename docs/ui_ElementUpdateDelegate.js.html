<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: ui/ElementUpdateDelegate.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: ui/ElementUpdateDelegate.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Requiem
 * (c) VARIANTE (http://variante.io)
 *
 * This software is released under the MIT License:
 * http://www.opensource.org/licenses/mit-license.php
 */

'use strict';

import assert from '../helpers/assert';
import debounce from '../helpers/debounce';
import DirtyType from '../enums/DirtyType';
import EventType from '../enums/EventType';

/**
 * Default refresh (debounce) rate in milliseconds.
 *
 * @const
 * @memberof module:requiem~ui.ElementUpdateDelegate
 * @type {number}
 * @default
 */
const DEFAULT_REFRESH_RATE = 0.0;

/**
 * @class
 *
 * Delegate for managing update calls of a Requiem Element.
 *
 * @alias module:requiem~ui.ElementUpdateDelegate
 */
class ElementUpdateDelegate {
  /**
   * @class
   *
   * Creates a new ElementUpdateDelegate instance.
   *
   * @param {Element} delegate - The Requiem Element instance of which this
   *                             ElementUpdateDelgate instance manages.
   *
   * @alias module:requiem~ui.ElementUpdateDelegate
   */
  constructor(delegate) {
    this.__define_properties();

    let mDirtyTable = 0;
    let mConductorTable = {};
    let mResizeHandler = null;
    let mScrollHandler = null;
    let mMouseMoveHandler = null;
    let mOrientationChangeHandler = null;
    let mMouseWheelHandler = null;
    let mKeyUpHandler = null;
    let mKeyPressHandler = null;
    let mKeyDownHandler = null;

    this.delegate = delegate;

    /**
     * Custom requestAnimationFrame implementation.
     *
     * @param {Function} callback
     *
     * @private
     */
    let _requestAnimationFrame = (callback) => {
      let raf = window &amp;&amp; (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame) || null;
      if (!raf) raf = (callback) => (window.setTimeout(callback, 10.0));
      return raf(callback);
    };

    /**
     * Custom cancelAnimationFrame implementation.
     *
     * @return {Function} callback
     *
     * @private
     */
    let _cancelAnimationFrame = function(callback) {
      let caf = window &amp;&amp; (window.requestAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame) || null;
      if (!caf) caf = (callback) => (window.clearTimeout(callback));
      return caf;
    };

    /**
     * Handler invoked when the window resizes.
     *
     * @param {Event} event
     *
     * @private
     */
    let _onWindowResize = (event) => this.setDirty(DirtyType.SIZE);

    /**
     * Handler invoked when the window scrolls.
     *
     * @param {Event} event
     *
     * @private
     */
    let _onWindowScroll = (event) => this.setDirty(DirtyType.POSITION);

    /**
     * Handler invoked when mouse moves in the window.
     *
     * @param {Event} event
     *
     * @private
     */
    let _onWindowMouseMove = (event) => {
      this.mouse.pointerX = event.clientX;
      this.mouse.pointerY = event.clientY;
      this.setDirty(DirtyType.INPUT);
    };

    /**
     * Handler invoked when mouse wheel moves in the window.
     *
     * @param {Event} event
     *
     * @private
     */
    let _onWindowMouseWheel = (event) => {
      this.mouse.wheelX = event.deltaX;
      this.mouse.wheelY = event.deltaY;
      this.setDirty(DirtyType.INPUT);
    };

    /**
     * Handler invoked when device orientation changes.
     *
     * @param {Event} event
     *
     * @private
     */
    let _onWindowOrientationChange = (event) => {
      let x, y, z;

      if (event instanceof window.DeviceOrientationEvent) {
        x = event.beta;
        y = event.gamma;
        z = event.alpha;
      }
      else if (event instanceof window.DeviceMotionEvent) {
        x = event.acceleration.x * 2;
        y = event.acceleration.y * 2;
        z = event.acceleration.z * 2;
      }
      else {
        x = event.orientation.x * 50;
        y = event.orientation.y * 50;
        z = event.orientation.z * 50;
      }

      this.orientation.x = x;
      this.orientation.y = y;
      this.orientation.z = z;

      this.setDirty(DirtyType.ORIENTATION);
    };

    /**
     * Handler invoked when a key is pressed down.
     *
     * @param {Event} event
     *
     * @private
     */
    let _onWindowKeyDown = (event) => {
      if (this.keyCode.down === undefined) this.keyCode.down = [];
      this.keyCode.down.push(event.keyCode);
      this.setDirty(DirtyType.INPUT);
    };

    /**
     * Handler invoked when a key is pressed.
     *
     * @param {Event} event
     *
     * @private
     */
    let _onWindowKeyPress = (event) => {
      if (this.keyCode.press === undefined) this.keyCode.press = [];
      this.keyCode.press.push(event.keyCode);
      this.setDirty(DirtyType.INPUT);
    };

    /**
     * Handler invoked when a key is pressed up.
     *
     * @param {Event} event
     *
     * @private
     */
    let _onWindowKeyUp = (event) => {
      if (this.keyCode.up === undefined) this.keyCode.up = [];
      this.keyCode.up.push(event.keyCode);
      this.setDirty(DirtyType.INPUT);
    };

    /**
     * Sets a dirty type as dirty.
     *
     * @param {number} dirtyType
     */
    this.setDirty = (dirtyType, validateNow) => {
      if (this.transmissive !== DirtyType.NONE) {
        if (this.delegate.children) {
          for (let name in this.delegate.children) {
            let children;

            if (this.delegate.children[name] instanceof Array) {
              children = this.delegate.children[name];
            } else {
              children = [this.delegate.children[name]];
            }

            let n = children.length;

            for (let i = 0; i &lt; n; i++) {
              let child = children[i];

              if (child.updateDelegate &amp;&amp; child.updateDelegate.setDirty) {
                let transmitted = dirtyType &amp; child.updateDelegate.receptive;

                if (transmitted !== DirtyType.NONE) {
                  child.updateDelegate.setDirty(transmitted, validateNow);
                }
              }
            }
          }
        }
      }

      if (this.isDirty(dirtyType) &amp;&amp; !validateNow) return;

      switch (dirtyType) {
        case DirtyType.NONE:
        case DirtyType.ALL:
          mDirtyTable = dirtyType;
          break;
        default:
          mDirtyTable |= dirtyType;
      }

      if (validateNow) {
        this.update();
      }
      else if (!this._pendingAnimationFrame) {
        this._pendingAnimationFrame = _requestAnimationFrame(this.update.bind(this));
      }
    };

    /**
     * Checks dirty status of a given dirty type.
     *
     * @param {number} dirtyType [description]
     *
     * @return {boolean}
     */
    this.isDirty = (dirtyType) => {
      switch (dirtyType) {
        case DirtyType.NONE:
        case DirtyType.ALL:
          return (mDirtyTable === dirtyType);
        default:
          return ((dirtyType &amp; mDirtyTable) !== 0);
      }
    };

    /**
     * Initializes this ElementUpdateDelegate instance. Must manually invoke.
     */
    this.init = () => {
      this.setDirty(DirtyType.ALL);
    };

    /**
     * Destroys this ElementUpdateDelegate instance.
     */
    this.destroy = () => {
      _cancelAnimationFrame();

      if (mResizeHandler) {
        window.removeEventListener(EventType.OBJECT.RESIZE, mResizeHandler);
        window.removeEventListener(EventType.DEVICE.ORIENTATION_CHANGE, mResizeHandler);
      }

      if (mScrollHandler) {
        let conductor = mConductorTable.scroll || window;
        conductor.removeEventListener(EventType.OBJECT.SCROLL, mScrollHandler);
      }

      if (mMouseWheelHandler) {
        let conductor = mConductorTable.mouseWheel || window;
        conductor.removeEventListener(EventType.MISC.WHEEL, mMouseWheelHandler);
      }

      if (mMouseMoveHandler) {
        let conductor = mConductorTable.mouseMove || window;
        conductor.removeEventListener(EventType.MOUSE.MOUSE_MOVE, mMouseMoveHandler);
      }

      if (mOrientationChangeHandler) {
        if (window.DeviceOrientationEvent)
          window.removeEventListener(EventType.DEVICE.DEVICE_ORIENTATION, mOrientationChangeHandler);
        else if (window.DeviceMotionEvent)
          window.removeEventListener(EventType.DEVICE.DEVICE_MOTION, mOrientationChangeHandler);
      }

      if (mKeyDownHandler) window.removeEventListener(EventType.KEYBOARD.KEY_DOWN, mKeyDownHandler);
      if (mKeyPressHandler) window.removeEventListener(EventType.KEYBOARD.KEY_PRESS, mKeyPressHandler);
      if (mKeyUpHandler) window.removeEventListener(EventType.KEYBOARD.KEY_UP, mKeyUpHandler);

      mResizeHandler = null;
      mScrollHandler = null;
      mMouseWheelHandler = null;
      mMouseMoveHandler = null;
      mOrientationChangeHandler = null;
      mKeyDownHandler = null;
      mKeyPressHandler = null;
      mKeyUpHandler = null;
      mConductorTable = null;
    };

    /**
     * Handler invoked whenever a visual update is required.
     */
    this.update = () => {
      _cancelAnimationFrame(this._pendingAnimationFrame);

      if (this.delegate &amp;&amp; this.delegate.update)
        this.delegate.update.call(this.delegate);

      // Reset the dirty status of all types.
      this.setDirty(DirtyType.NONE);

      delete this.mouse.pointerX;
      delete this.mouse.pointerY;
      delete this.mouse.wheelX;
      delete this.mouse.wheelY;
      delete this.orientation.x;
      delete this.orientation.y;
      delete this.orientation.z;
      delete this.keyCode.up;
      delete this.keyCode.press;
      delete this.keyCode.down;

      this._pendingAnimationFrame = null;
    };

    /**
     * Sets up the responsiveness to the provided conductor. Only the following
     * event types support a custom conductor; the rest uses window as the
     * conductor:
     *   1. EventType.OBJECT.SCROLL
     *   2. EventType.MISC.WHEEL
     *   3. EventType.MOUSE_MOUSE_MOVE
     *
     * @param {Object|Number|...args} - This could be the conductor (defaults to
     *                                  window if unspecified), refresh rate
     *                                  (defaults to the default value if
     *                                  unspecified) or the EventType(s).
     * @param {number|...args}        - Either the refresh rate (defaults to
     *                                  the default value if unspecified) or
     *                                  the EventType(s).
     * @param {...args}               - EventType(s) which the delegate will
     *                                  respond to.
     */
    this.initResponsiveness = function() {
      let args = Array.prototype.slice.call(arguments);

      assert(args.length > 0, 'Insufficient arguments provided');

      let conductor = ((typeof args[0] !== 'number') &amp;&amp; (typeof args[0] !== 'string')) ? args.shift() : window;
      let delay = (typeof args[0] === 'number') ? args.shift() : DEFAULT_REFRESH_RATE;
      let universal = (args.length === 0);

      assert(conductor &amp;&amp; conductor.addEventListener, 'Invalid conductor specified');

      if (universal || args.indexOf(EventType.OBJECT.RESIZE) > -1 || args.indexOf(EventType.DEVICE.ORIENTATION_CHANGE) > -1) {
        if (mResizeHandler) {
          window.removeEventListener(EventType.OBJECT.RESIZE, mResizeHandler);
          window.removeEventListener(EventType.DEVICE.ORIENTATION_CHANGE, mResizeHandler);
        }
        mResizeHandler = (delay === 0.0) ? _onWindowResize.bind(this) : debounce(_onWindowResize.bind(this), delay);
        window.addEventListener(EventType.OBJECT.RESIZE, mResizeHandler);
        window.addEventListener(EventType.DEVICE.ORIENTATION_CHANGE, mResizeHandler);
      }

      if (universal || args.indexOf(EventType.OBJECT.SCROLL) > -1) {
        if (mScrollHandler) {
          let c = mConductorTable.scroll || window;
          c.removeEventListener(EventType.OBJECT.SCROLL, mScrollHandler);
        }
        mScrollHandler = (delay === 0.0) ? _onWindowScroll.bind(this) : debounce(_onWindowScroll.bind(this), delay);
        mConductorTable.scroll = conductor;
        conductor.addEventListener(EventType.OBJECT.SCROLL, mScrollHandler);
      }

      if (universal || args.indexOf(EventType.MISC.WHEEL) > -1) {
        if (mMouseWheelHandler) {
          let c = mConductorTable.mouseWheel || window;
          c.removeEventListener(EventType.MISC.WHEEL, mMouseWheelHandler);
        }
        mMouseWheelHandler = (delay === 0.0) ? _onWindowMouseWheel.bind(this) : debounce(_onWindowMouseWheel.bind(this), delay);
        mConductorTable.mouseWheel = conductor;
        conductor.addEventListener(EventType.MISC.WHEEL, mMouseWheelHandler);
      }

      if (universal || args.indexOf(EventType.MOUSE.MOUSE_MOVE) > -1) {
        if (mMouseMoveHandler) {
          let c = mConductorTable.mouseMove || window;
          c.removeEventListener(EventType.MOUSE.MOUSE_MOVE, mMouseMoveHandler);
        }
        mMouseMoveHandler = (delay === 0.0) ? _onWindowMouseMove.bind(this) : debounce(_onWindowMouseMove.bind(this), delay);
        mConductorTable.mouseMove = conductor;
        conductor.addEventListener(EventType.MOUSE.MOUSE_MOVE, mMouseMoveHandler);
      }

      if (universal || args.indexOf(EventType.DEVICE.DEVICE_ORIENTATION) > -1 || args.indexOf(EventType.DEVICE.DEVICE_MOTION) > -1 || args.indexOf(EventType.DEVICE.ORIENTATION) > -1) {
        if (mOrientationChangeHandler) {
          if (window.DeviceOrientationEvent)
            window.removeEventListener(EventType.DEVICE.DEVICE_ORIENTATION, mOrientationChangeHandler);
          else if (window.DeviceMotionEvent)
            window.removeEventListener(EventType.DEVICE.DEVICE_MOTION, mOrientationChangeHandler);
        }
        mOrientationChangeHandler = (delay === 0.0) ? _onWindowOrientationChange.bind(this) : debounce(_onWindowOrientationChange.bind(this), delay);
        if (window.DeviceOrientationEvent)
          window.addEventListener(EventType.DEVICE.DEVICE_ORIENTATION, mOrientationChangeHandler);
        else if (window.DeviceMotionEvent)
          window.addEventListener(EventType.DEVICE.DEVICE_MOTION, mOrientationChangeHandler);
      }

      if (universal || args.indexOf(EventType.KEYBOARD.KEY_DOWN) > -1) {
        if (mKeyDownHandler) window.removeEventListener(EventType.KEYBOARD.KEY_DOWN, mKeyDownHandler);
        mKeyDownHandler = _onWindowKeyDown.bind(this);
        window.addEventListener(EventType.KEYBOARD.KEY_DOWN, mKeyDownHandler);
      }

      if (universal || args.indexOf(EventType.KEYBOARD.KEY_PRESS) > -1) {
        if (mKeyPressHandler) window.removeEventListener(EventType.KEYBOARD.KEY_PRESS, mKeyPressHandler);
        mKeyPressHandler = _onWindowKeyPress.bind(this);
        window.addEventListener(EventType.KEYBOARD.KEY_PRESS, mKeyPressHandler);
      }

      if (universal || args.indexOf(EventType.KEYBOARD.KEY_UP) > -1) {
        if (mKeyUpHandler) window.removeEventListener(EventType.KEYBOARD.KEY_UP, mKeyUpHandler);
        mKeyUpHandler = _onWindowKeyUp.bind(this);
        window.addEventListener(EventType.KEYBOARD.KEY_UP, mKeyUpHandler);
      }
    };
  }

  /**
   * Gets the string representation of this ElementUpdateDelegate instance.
   *
   * @return {string}
   */
  toString() {
    return '[ElementUpdateDelegate{' + ((this.delegate &amp;&amp; this.delegate.name) || 'undefined') + '}]';
  }

  /**
   * Defines all properties.
   *
   * @private
   */
  __define_properties() {
    /**
     * Delegate of this ElementUpdateDelegate instance.
     *
     * @property {Element}
     */
    this.delegate = null;

    /**
     * Indicates the dirty flags in which ElementUpdateDelgate instance will
     * transmit to its child Elements.
     *
     * @property {number}
     */
    this.transmissive = DirtyType.NONE;

    /**
     * Indicates the dirty flags in which this ElementUpdateDelegate is capable
     * of receiving from parent Elements.
     *
     * @property {number}
     */
    this.receptive = DirtyType.NONE;

    /**
     * Stores mouse properties if this ElementUpdateDelegate responds to mouse
     * events.
     *
     * @property {Object}
     */
    this.mouse = {};

    /**
     * Stores orientation properties if this ElementUpdateDelgate responds to
     * device orientations (i.e. device accelerometer).
     *
     * @property {Object}
     */
    this.orientation = {};

    /**
     * Stores pressed keycodes if this ElementUpdateDelegate responds to
     * keyboard events.
     *
     * @property {Object}
     */
    this.keyCode = {};
  }
}

module.exports = ElementUpdateDelegate;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-requiem.html">requiem</a></li></ul><h3>Classes</h3><ul><li><a href="AssetLoader.html">AssetLoader</a></li><li><a href="module-requiem-events.EventDispatcher.html">EventDispatcher</a></li><li><a href="module-requiem-events.EventTimer.html">EventTimer</a></li><li><a href="module-requiem-ui.Element.html">Element</a></li><li><a href="module-requiem-ui.ElementUpdateDelegate.html">ElementUpdateDelegate</a></li><li><a href="module-requiem-ui.Grid.html">Grid</a></li><li><a href="module-requiem-ui.Video.html">Video</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-requiem-dom.html">dom</a></li><li><a href="module-requiem-enums.html">enums</a></li><li><a href="module-requiem-events.html">events</a></li><li><a href="module-requiem-net.html">net</a></li><li><a href="module-requiem-ui.html">ui</a></li><li><a href="module-requiem-utils.html">utils</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Fri Mar 11 2016 18:42:16 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
